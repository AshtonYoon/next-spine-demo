import { useRef, useEffect } from "react";
import Head from "next/head";
import Image from "next/image";
import {
  SkeletonRenderer,
  AssetManager,
  AtlasAttachmentLoader,
  SkeletonJson,
  Skeleton,
  AnimationStateData,
  AnimationState,
  Downloader,
} from "@esotericsoftware/spine-canvas";

import styles from "../styles/Home.module.css";

export default function Home() {
  let lastFrameTime = Date.now() / 1000;
  const canvasRef = useRef<HTMLCanvasElement>(null);

  let context: CanvasRenderingContext2D | null;
  let canvas: HTMLCanvasElement | null;
  let assetManager: AssetManager | null;
  let skeleton: Skeleton | null;
  let animationState: AnimationState | null;
  let bounds: {
    x: number;
    y: number;
    width: number;
    height: number;
  } | null;
  let skeletonRenderer: SkeletonRenderer | null;

  const load = async () => {
    if (!canvasRef.current) return;

    canvas = canvasRef.current;
    context = canvas.getContext("2d");

    if (!context) return;

    skeletonRenderer = new SkeletonRenderer(context);

    // Load the assets.
    assetManager = new AssetManager("", new Downloader());
    assetManager.loadJson;
    assetManager.loadText("spineboy-ess.json");
    assetManager.loadTextureAtlas("spineboy.atlas");
    await assetManager.loadAll();

    // Create the texture atlas and skeleton data.
    let atlas = assetManager.require("spineboy.atlas");
    let atlasLoader = new AtlasAttachmentLoader(atlas);
    let skeletonJson = new SkeletonJson(atlasLoader);
    let skeletonData = skeletonJson.readSkeletonData(
      assetManager.require("spineboy-ess.json")
    );

    // Instantiate a new skeleton based on the atlas and skeleton data.
    skeleton = new Skeleton(skeletonData);
    skeleton.setToSetupPose();
    skeleton.updateWorldTransform();
    bounds = skeleton.getBoundsRect();
    // Setup an animation state with a default mix of 0.2 seconds.
    var animationStateData = new AnimationStateData(skeleton.data);
    animationStateData.defaultMix = 0.2;
    animationState = new AnimationState(animationStateData);

    // Set the run animation, looping.
    animationState.setAnimation(0, "run", true);

    console.log(skeleton);
    // Start rendering.
    requestAnimationFrame(render);
  };

  const render = () => {
    if (
      !canvas ||
      !context ||
      !skeleton ||
      !bounds ||
      !animationState ||
      !skeletonRenderer
    )
      return;

    // Calculate the delta time between this and the last frame in seconds.
    var now = Date.now() / 1000;
    var delta = now - lastFrameTime;
    lastFrameTime = now;

    // Resize the canvas drawing buffer if the canvas CSS width and height changed
    // and clear the canvas.
    if (
      canvas.width != canvas.clientWidth ||
      canvas.height != canvas.clientHeight
    ) {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    context.clearRect(0, 0, canvas.width, canvas.height);

    // Center the skeleton and resize it so it fits inside the canvas.
    skeleton.x = canvas.width / 2;
    skeleton.y = canvas.height - canvas.height * 0.1;
    let scale = (canvas.height / bounds.height) * 0.8;
    skeleton.scaleX = scale;
    skeleton.scaleY = -scale;

    // Update and apply the animation state, update the skeleton's
    // world transforms and render the skeleton.
    animationState.update(delta);
    animationState.apply(skeleton);
    skeleton.updateWorldTransform();
    skeletonRenderer.draw(skeleton);

    requestAnimationFrame(render);
  };

  useEffect(() => {
    load();
  }, []);

  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={styles.main}>
        <canvas ref={canvasRef} style={{ width: "500px", height: "500px" }} />
      </main>
    </div>
  );
}
